/*
 * Star Trek Timelines Datasheet Updater
 *
 * Updates the datasheet generated by datacore.app directly from JSON data contained in a google drive file.
 *
 * Released under an Apache 3.0 licence
 */
 
/* Used to identify the file on Google Drive that contains data from disruptorbeam.com/player */
const GOOGLE_DRIVE_FILEID = 'INSERT_ID_HERE';
 
/**
 * Adds menu items for importing data
 * @param {Event} e The onOpen event.
 */
function onOpen(e) {
  // Add a custom menu to the spreadsheet.
  SpreadsheetApp.getUi() // Or DocumentApp, SlidesApp, or FormApp.
      .createMenu('Import data')
      .addItem('Import crew data', 'importCrewData')
      .addItem('Import item data', 'importItemData')
      .addSeparator()
      .addItem('Create backup sheet', 'createBackup')
      .addItem('Restore backup sheet', 'restoreBackup')
      .addToUi();
}

function importData_() {
  let file = DriveApp.getFileById(GOOGLE_DRIVE_FILEID);
  return JSON.parse(file.getBlob().getDataAsString());
}

/** Creates a backup of the active sheet */
function createBackup() {
  let ss = SpreadsheetApp.getActive();
  let sheetName = ss.getActiveSheet().getName();
  ss.duplicateActiveSheet().setName(sheetName + ' (backup)').hideSheet();
}

/** Restores a backup of the active sheet */
function restoreBackup() {
  let ss = SpreadsheetApp.getActive();
  let targetSheet = ss.getActiveSheet();
  let backupSheet = ss.getSheetByName(targetName + ' (backup)');
  
  if (backupSheet != null) {_
    replaceContents_(targetSheet, backupSheet.getRange(1, 1, backupSheet.getLastRow(), backupSheet.getLastColumn()).getValues());
  } else {
    SpreadsheetApp.getUi().alert('There is no backup sheet!');
  }
/*
 * Star Trek Timelines Datasheet Updater
 *
 * Updates the datasheet generated by datacore.app directly from JSON data contained in a google drive file.
 *
 * Released under an Apache 3.0 licence
 */
 
/* Used to identify the file on Google Drive that contains data from disruptorbeam.com/player */
const GOOGLE_DRIVE_FILEID = '1ULabMgdcim5-thIe3K04J6USq9jSLLvr';//'INSERT_ID_HERE';
 
/**
 * Adds menu items for importing data
 * @param {Event} e The onOpen event.
 */
function onOpen(e) {
  // Add a custom menu to the spreadsheet.
  SpreadsheetApp.getUi() // Or DocumentApp, SlidesApp, or FormApp.
      .createMenu('Import data')
      .addItem('Import crew data', 'importCrewData')
      .addItem('Import item data', 'importItemData')
      .addItem('Import voyage data', 'importVoyageData')
      .addSeparator()
      .addItem('Import all data', 'importAllData')
      .addToUi();
}

function importData_() {
  let file = DriveApp.getFileById(GOOGLE_DRIVE_FILEID);
  return JSON.parse(file.getBlob().getDataAsString());
}

function replaceContents_(sheet, newContent) {
  sheet.clearContents();
  sheet.getRange(1, 1, newContent.length, newContent[0].length).setValues(newContent);
}

function getSheetAsRange_(sheet) {
  return sheet.getRange(1, 1, sheet.getLastRow(), sheet.getLastColumn());
}

const BATCH_IMPORT_ERROR = 363;
const OCCUPIED_RANGE_NOTE = "Data sheet used";
const OCCUPIED_PROMPT = `You are replacing different an existing import sheet. 
                          Do you want to do this?`;
const OCCUPIED_ERROR = 'Sheet already used';

function getTargetSheet_(name, create) {
  let ss = SpreadsheetApp.getActiveSpreadsheet(); 
  let range = ss.getRangeByName(name);
  
  if (range == null && create) {
    range = ss.getActiveSheet().getRange(1, 1);
    let overlaps = ss.getNamedRanges().filter(r => range.getSheet() == r.getRange().getSheet());
    if (overlaps.length != 0) {
      let ui = SpreadsheetApp.getUi();
      let response = ui.alert(OCCUPIED_PROMPT,
                              ui.ButtonSet.YES_NO);
                             
      if (response != ui.Button.YES)
        throw OCCUPIED_ERROR;
        
      overlaps.forEach(r => ss.removeNamedRange(r.getName()));
    } 
    ss.setNamedRange(name, range);
  } 
    
  if (range == null)
    throw BATCH_IMPORT_ERROR;
  
  return range.getSheet();
}

function importAllData() {
  const allDataFuncs = [ importCrewData, importItemData, importVoyageData ];
  let successes = 0;
  
  allDataFuncs.forEach(func => {
    try {
      func(true);
      ++successes;
    } catch (e) {
      if (e != BATCH_IMPORT_ERROR)
        throw e;
    }   
  });
  
  let message = successes ? `Successfully imported ${successes} data sets` : 
                            'Please import data set individually before using batch update';
  SpreadsheetApp.getUi().alert(message); 
}

function createColumnUpdaters_() {
  const stat = (skill, type) => (data, id) => {
    let name = skill +  '_skill';
    let skills = new Object(data.skills);
    
    if (!Object.keys(skills).includes(name)) 
      return 0;
    
    if (type != 'core')
      type = 'range_' + type;
      
    return data.skills[name][type]
  };
  
  const value = val => (d, id) => val;
  const fromPlayer = path => (data, id) => {
    let indicies = path.split('/');
    let retVal = data;
    
    for (index in indicies) 
      retVal = retVal[indicies[index]];
    
    return retVal;
  }
  const fromImmortals = index => (pd, id) => id[index];
  const fromImmortalsNum = index => (pd, id) => parseInt(id[index].slice(1));
  const parseCollections = (pd, id) => ""; // TODO
  const isFrozen = (pd, id) => pd != null;
  const inPortal = (pd, id) => id[31] == 'y';
  
  return [[
    fromPlayer('name'), value(true), fromPlayer('short_name'),
    fromPlayer('max_rarity'), fromPlayer('rarity'), fromPlayer('level'), value(0),
    (data, id) => { let values = []; for (equip in data.equipment) {values.push(data.equipment[equip][0]); }; return values.join(' '); },
    fromPlayer('equipment_rank'), inPortal, parseCollections, 
    fromImmortalsNum(26), (pd, id) => pd.location,
    stat('command', 'core'), stat('command', 'min'), stat('command', 'max'),
    stat('diplomacy', 'core'), stat('diplomacy', 'min'), stat('diplomacy', 'max'),
    stat('engineering', 'core'), stat('engineering', 'min'), stat('engineering', 'max'),
    stat('medical', 'core'), stat('medical', 'min'), stat('medical', 'max'),
    stat('science', 'core'), stat('science', 'min'), stat('science', 'max'),
    stat('security', 'core'), stat('security', 'min'), stat('security', 'max'),
    fromImmortals(21), fromPlayer('action/name'), 
    (data, id) => ['Attack','Evasion','Accuracy'][data.action.boost_type],
    fromPlayer('action/bonus_amount'), fromPlayer('action/initial_cooldown'), fromPlayer('action/duration'), fromPlayer('action/cooldown'),
    value(''), value(''), value(''), value(''), value(''), value(''), value(''),
    fromPlayer('archetype_id')
  ],
  [
    fromImmortals(0), fromPlayer('frozen'), fromImmortals(2),
    fromImmortals(1), fromImmortals(1), value(100), fromPlayer('copies'),
    value(''), value(9), inPortal, parseCollections,
    fromImmortalsNum(26), value('N/A'),
    fromImmortals(3), fromImmortals(4), fromImmortals(5),
    fromImmortals(6), fromImmortals(7), fromImmortals(8),
    fromImmortals(9), fromImmortals(10), fromImmortals(11),
    fromImmortals(12), fromImmortals(13), fromImmortals(14),
    fromImmortals(15), fromImmortals(16), fromImmortals(17),
    fromImmortals(18), fromImmortals(19), fromImmortals(20),
    fromImmortals(21), value(''), 
    value(''), value(''),
    value(''), value(''), value(''), value(''), value(''),
    value(''), value(''), value(''), value(''), value(''),
    fromPlayer('archetype_id', '')
  ]];
}


class CrewMap extends Map {
  add(character) {
      if (this.has(character.name)) 
        character.duplicate = this.get(character.name);
      else
        character.duplicate = false;
        
      this.set(character.name, character);
  }
}

/** Imports crew data from an JSON file on */
function importCrewData(batch) {
  let app = SpreadsheetApp;
  let sheet = getTargetSheet_('RawCrewData', !batch);
  // Data from The Big Book of Backend Data
  let immortalss = app.openById('1iYP_XqIvaGKgvINqk7vaQwfYhaSIXWatD3YD09DAXwY');
  let immortalData = getSheetAsRange_(immortalss.getSheetByName('Raw Crew Data')).getValues();
  let [playerUpdaters, immortalUpdaters] = createColumnUpdaters_();
  let parsedData = importData_();
  let crewMap = new CrewMap();
  
  // Setup map of active crew
  for (i in parsedData.player.character.crew) {
    let character = parsedData.player.character.crew[i];
    
    if (!character.in_buy_back_state) {
      character.frozen = false;
      character.copies = 1;
      
      crewMap.add(character);
    }
  }
  
  if (sheet.getLastRow() > 1) {
    // Attempt to find frozen crew
    let crewNames = sheet.getRange(2, 1, sheet.getLastRow()).getValues().flat(); 
    let archetypeIds = sheet.getRange(2, sheet.getLastColumn(), sheet.getLastRow()).getValues().flat();
    
    for (i in parsedData.player.character.stored_immortals) {
      let immortal = parsedData.player.character.stored_immortals[i];
      let crewIndex = archetypeIds.indexOf(immortal.id);
      
      if (crewIndex >= 0) {
        let crewName = crewNames[crewIndex];
        crewMap.add({
          'name' : crewName,
          'frozen' : true,
          'archtype_id' : immortal.id, 
          'copies' : immortal.quantity
        });
      }
    }
  }
  
  let outputData = new Array();

  const headers = [
    'Name',	'Have', 'Short name', 
    'Max rarity', 'Rarity', 'Level', 'Frozen', 
    'Equipment', 'Tier', 'In portal', 'Collections',
    'Voyage Rank', 'Location',
    'Command Core', 'Command Min', 'Command Max',
    'Diplomacy Core', 'Diplomacy Min', 'Diplomacy Max', 
    'Engineering Core', 'Engineering Min', 'Engineering Max',
    'Medicine Core', 'Medicine Min', 'Medicine Max',
    'Science Core', 'Science Min', 'Science Max',
    'Security Core', 'Security Min', 'Security Max',
    'Traits', 'Action name', 'Boosts Amount',
    'Initialize	Duration', 'Cooldown', 'Bonus Ability',
    'Trigger Uses per Battle (Not Used)', 'Handicap Type (Not Used)','Handicap Amount (Not Used)',
    'Accuracy', 'Crit Bonus', 'Crit Rating', 'Evasion', 'Charge Phases (Not Used)',
    'Character ID'];
  outputData.push(headers);
  
  let crewOwned = 0;
  let crewFrozen = 0;
  
  for (let row = 2; row < immortalData.length; ++row) {
    let crewName = immortalData[row][0];
    //console.info('Looking at ' + characterName);
    if (crewName == '')
      continue;
      
    let crew = crewMap.has(crewName) ? crewMap.get(crewName) : { 'name' : crewName, 'frozen' : true, 'copies' : 0 };
          
    while (crew) {
      let outputRow = [];
      let updaters = !crew.frozen ? playerUpdaters : immortalUpdaters;
      
      for (let column = 0; column < headers.length; ++column)  
        outputRow.push(updaters[column](crew, immortalData[row]));
      
      if (crew.frozen) 
        crewFrozen += crew.copies;
      else
        ++crewOwned;
      
      outputData.push(outputRow);
      crew = crew.duplicate;
    }
  }
  
  replaceContents_(sheet, outputData);
  app.getUi().alert(`You own ${crewOwned} crew and have ${crewFrozen} in the freezer.`);
}

/** Import Name, Rarity and quantity owned of every item into active sheet */
function importItemData(batch) {
  let targetSheet = getTargetSheet_('RawItemData', !batch);
  let items = importData_().player.character.items;
  let outputMap = new CrewMap();
  let output = [];
  
  output.push(['Name', 'Basic', 'Common', 'Uncommon', 'Rare', 'Super rare', 'Legendary']);
  
  for (i in items) {
    let item = items[i];
    if (!outputMap.has(item.name)) 
      outputMap.set(item.name, [item.name, 0, 0, 0, 0, 0, 0]);
    
    outputMap.get(item.name)[item.rarity + 1] = item.quantity;
  }
  
  let sortedKeys = Array.from(outputMap.keys()).sort();
  
  for (key in sortedKeys)
    output.push(outputMap.get(sortedKeys[key]));
    
  replaceContents_(targetSheet, output);
}

/** Import Voyage data into active sheet */
function importVoyageData(batch) {
  let targetSheet = getTargetSheet_("RawVoyageData", !batch);
  let output = [];
  let data = importData_().player.character;
  let voyageData = data.voyage_descriptions[0];
  
  let skillTypeMap = new Map();
  skillTypeMap.set(voyageData.skills.primary_skill, 'Primary');
  skillTypeMap.set(voyageData.skills.secondary_skill, 'Secondary');
  
  const parseTrait = trait => trait.replace('_', ' ')
                                   .replace('doctor', 'Physician')
                                   .replace(/\b(\w)/g, c => c.toUpperCase());
  
  let current = data.voyage[0];
  let voyager = current ? slot => current.crew_slots[slot].crew.name : slot => "None";
  
  output.push(["Voyage Status:", "", current ? current.state : "Not out", "", "", ""]);
  output.push(['', '', '', '', '', '']);
  output.push(['Skill', 'Type', 'Trait 1', 'Voyager 1', 'Trait 2', 'Voyager 2']);
  
  for (let i = 0; i < voyageData.crew_slots.length; i += 2) {
    let slot1 = voyageData.crew_slots[i];
    let slot2 = voyageData.crew_slots[i+1];
    let skill = slot1.skill;
    
    output.push([skill.charAt(0).toUpperCase() + skill.slice(1, -6), 
                 skillTypeMap.has(skill) ? skillTypeMap[skill] : 'Standard', 
                 parseTrait(slot1.trait), 
                 voyager(i),
                 parseTrait(slot2.trait),
                 voyager(i+1)]);
  }
  
  replaceContents_(targetSheet, output);
}
  let parsedData = importData_();
  let app = SpreadsheetApp;
  let sheet = app.getActiveSheet();
  let crewMap = new Map();

  for (i in parsedData.player.character.crew) {
    var character = parsedData.player.character.crew[i];
    
    if (!character.in_buy_back_state) {
      if (crewMap.has(character.name)) 
        character.duplicate = crewMap.get(character.name);
      else
        character.duplicate = false;
        
      crewMap.set(character.name, character);
    }
  }
  
  let headers = sheet.getRange(1, 1, 1, sheet.getLastColumn()).getDisplayValues()[0];
  let dataRange = sheet.getRange(2, 1, sheet.getLastRow(), sheet.getLastColumn());
  let sheetData = dataRange.getValues();
  let outputData = new Array();
  outputData.push(headers);
  
  let charactersUpdated = 0;
  let charactersFrozen = 0;
  
  for (let row = 0; row < sheetData.length; ++row) {
    let characterName = sheetData[row][0];
    //console.info("Looking at " + characterName);
   
    if (crewMap.has(characterName)) {
      console.info("Character " + characterName + " being updated");
      let character = crewMap.get(characterName);
      
      while (character) {
        let outputRow = new Array();
        for (let column = 0; column < headers.length; ++column) 
          outputRow.push(columnUpdaters[column](character, headers[column], sheetData[row][column]));
        
        outputData.push(outputRow);
        character = character.duplicate;
        ++charactersUpdated;
      }
      
      crewMap.delete(characterName);
    } else if (sheetData[row][1] && isImortalised(sheetData[row])) {
      // Frozen
      sheetData[row][6] = 1;
      outputData.push(sheetData[row]);
      ++charactersFrozen;
    } else {
      // TODO: Use 100 stat
    }
  }
  
  replaceContents_(sheet, outputData);
  SpreadsheetApp.getUi().alert(charactersUpdated.toString() + " characters updated and " + charactersRemoved.toString() + " characters removed.");
}

/** Import Name, Rarity and quantity owned of every item into active sheet */
function importItemData() {
  let items = importData_().player.character.items;
  let outputMap = new Map();
  let output = new Array();
  
  output.push(['Name', 'Basic', 'Common', 'Uncommon', 'Rare', 'Super rare', 'Legendary']);
  
  for (i in items) {
    let item = items[i];
    if (!outputMap.has(item.name)) 
      outputMap.set(item.name, [item.name, 0, 0, 0, 0, 0, 0]);
    
    outputMap.get(item.name)[item.rarity + 1] = item.quantity;
  }
  
  let sortedKeys = Array.from(outputMap.keys()).sort();
  
  for (key in sortedKeys)
    output.push(outputMap.get(sortedKeys[key]));
    
  replaceContents_(SpreadsheetApp.getActiveSheet(), output);
}
/** Restores a backup of the active sheet */
function restoreBackup() {
  let ss = SpreadsheetApp.getActive();
  let targetSheet = ss.getActiveSheet();
  let backupSheet = ss.getSheetByName(targetName + ' (backup)');
  
  if (backupSheet != null) {_
    replaceContents_(targetSheet, backupSheet.getRange(1, 1, backupSheet.getLastRow(), backupSheet.getLastColumn()).getValues());
  } else {
    SpreadsheetApp.getUi().alert('There is no backup sheet!');
  }
}

function replaceContents_(sheet, newContent) {
  sheet.clearContents();
  sheet.getRange(1, 1, newContent.length, newContent[0].length).setValues(newContent);
}

function createColumnUpdaters_() {
/*
 * Star Trek Timelines Datasheet Updater
 *
 * Updates the datasheet generated by datacore.app directly from JSON data contained in a google drive file.
 *
 * Released under an Apache 3.0 licence
 */
 
/* Used to identify the file on Google Drive that contains data from disruptorbeam.com/player */
const GOOGLE_DRIVE_FILEID = '1ULabMgdcim5-thIe3K04J6USq9jSLLvr';//'INSERT_ID_HERE';
 
/**
 * Adds menu items for importing data
 * @param {Event} e The onOpen event.
 */
function onOpen(e) {
  // Add a custom menu to the spreadsheet.
  SpreadsheetApp.getUi() // Or DocumentApp, SlidesApp, or FormApp.
      .createMenu('Import data')
      .addItem('Import crew data', 'importCrewData')
      .addItem('Import item data', 'importItemData')
      .addItem('Import voyage data', 'importVoyageData')
      .addSeparator()
      .addItem('Import all data', 'importAllData')
      .addToUi();
}

function importData_() {
  let file = DriveApp.getFileById(GOOGLE_DRIVE_FILEID);
  return JSON.parse(file.getBlob().getDataAsString());
}

function replaceContents_(sheet, newContent) {
  sheet.clearContents();
  sheet.getRange(1, 1, newContent.length, newContent[0].length).setValues(newContent);
}

function getSheetAsRange_(sheet) {
  return sheet.getRange(1, 1, sheet.getLastRow(), sheet.getLastColumn());
}

const BATCH_IMPORT_ERROR = 363;
const OCCUPIED_RANGE_NOTE = "Data sheet used";
const OCCUPIED_PROMPT = `You are replacing different an existing import sheet. 
                          Do you want to do this?`;
const OCCUPIED_ERROR = 'Sheet already used';

function getTargetSheet_(name, create) {
  let ss = SpreadsheetApp.getActiveSpreadsheet(); 
  let range = ss.getRangeByName(name);
  
  if (range == null && create) {
    range = ss.getActiveSheet().getRange(1, 1);
    let overlaps = ss.getNamedRanges().filter(r => range.getSheet() == r.getRange().getSheet());
    if (overlaps.length != 0) {
      let ui = SpreadsheetApp.getUi();
      let response = ui.alert(OCCUPIED_PROMPT,
                              ui.ButtonSet.YES_NO);
                             
      if (response != ui.Button.YES)
        throw OCCUPIED_ERROR;
        
      overlaps.forEach(r => ss.removeNamedRange(r.getName()));
    } 
    ss.setNamedRange(name, range);
  } 
    
  if (range == null)
    throw BATCH_IMPORT_ERROR;
  
  return range.getSheet();
}

function importAllData() {
  const allDataFuncs = [ importCrewData, importItemData, importVoyageData ];
  let successes = 0;
  
  allDataFuncs.forEach(func => {
    try {
      func(true);
      ++successes;
    } catch (e) {
      if (e != BATCH_IMPORT_ERROR)
        throw e;
    }   
  });
  
  let message = successes ? `Successfully imported ${successes} data sets` : 
                            'Please import data set individually before using batch update';
  SpreadsheetApp.getUi().alert(message); 
}

function createColumnUpdaters_() {
  const stat = (skill, type) => (data, id) => {
    let name = skill +  '_skill';
    let skills = new Object(data.skills);
    
    if (!Object.keys(skills).includes(name)) 
      return 0;
    
    if (type != 'core')
      type = 'range_' + type;
      
    return data.skills[name][type]
  };
  
  const value = val => (d, id) => val;
  const fromPlayer = path => (data, id) => {
    let indicies = path.split('/');
    let retVal = data;
    
    for (index in indicies) 
      retVal = retVal[indicies[index]];
    
    return retVal;
  }
  const fromImmortals = index => (pd, id) => id[index];
  const fromImmortalsNum = index => (pd, id) => parseInt(id[index].slice(1));
  const parseCollections = (pd, id) => ""; // TODO
  const inPortal = (pd, id) => id[31] == 'y';
  
  return [[
    fromPlayer('name'), value(true), fromPlayer('short_name'),
    fromPlayer('max_rarity'), fromPlayer('rarity'), fromPlayer('level'), value(0),
    (data, id) => { let values = []; for (equip in data.equipment) {values.push(data.equipment[equip][0]); }; return values.join(' '); },
    fromPlayer('equipment_rank'), inPortal, parseCollections, 
    fromImmortalsNum(26), value(""),
    stat('command', 'core'), stat('command', 'min'), stat('command', 'max'),
    stat('diplomacy', 'core'), stat('diplomacy', 'min'), stat('diplomacy', 'max'),
    stat('engineering', 'core'), stat('engineering', 'min'), stat('engineering', 'max'),
    stat('medical', 'core'), stat('medical', 'min'), stat('medical', 'max'),
    stat('science', 'core'), stat('science', 'min'), stat('science', 'max'),
    stat('security', 'core'), stat('security', 'min'), stat('security', 'max'),
    fromImmortals(21), fromPlayer('action/name'), 
    (data, id) => ['Attack','Evasion','Accuracy'][data.action.boost_type],
    fromPlayer('action/bonus_amount'), fromPlayer('action/initial_cooldown'), fromPlayer('action/duration'), fromPlayer('action/cooldown'),
    value(''), value(''), value(''), value(''), value(''), value(''), value(''),
    fromPlayer('archetype_id')
  ],
  [
    fromImmortals(0), fromPlayer('frozen'), fromImmortals(2),
    fromImmortals(1), fromImmortals(1), value(100), fromPlayer('copies'),
    value(''), value(9), inPortal, parseCollections,
    fromImmortalsNum(26), value(''),
    fromImmortals(3), fromImmortals(4), fromImmortals(5),
    fromImmortals(6), fromImmortals(7), fromImmortals(8),
    fromImmortals(9), fromImmortals(10), fromImmortals(11),
    fromImmortals(12), fromImmortals(13), fromImmortals(14),
    fromImmortals(15), fromImmortals(16), fromImmortals(17),
    fromImmortals(18), fromImmortals(19), fromImmortals(20),
    fromImmortals(21), value(''), 
    value(''), value(''),
    value(''), value(''), value(''), value(''), value(''),
    value(''), value(''), value(''), value(''), value(''),
    fromPlayer('archetype_id', '')
  ]];
}


class CrewMap extends Map {
  add(character) {
      if (this.has(character.name)) 
        character.duplicate = this.get(character.name);
      else
        character.duplicate = false;
        
      this.set(character.name, character);
  }
}

/** Imports crew data from an JSON file on */
function importCrewData(batch) {
  let app = SpreadsheetApp;
  let sheet = getTargetSheet_('RawCrewData', !batch);
  // Data from The Big Book of Backend Data
  let immortalss = app.openById('1iYP_XqIvaGKgvINqk7vaQwfYhaSIXWatD3YD09DAXwY');
  let immortalData = getSheetAsRange_(immortalss.getSheetByName('Raw Crew Data')).getValues();
  let [playerUpdaters, immortalUpdaters] = createColumnUpdaters_();
  let parsedData = importData_();
  let crewMap = new CrewMap();
  
  // Setup map of active crew
  for (i in parsedData.player.character.crew) {
    let character = parsedData.player.character.crew[i];
    
    if (!character.in_buy_back_state) {
      character.frozen = false;
      character.copies = 1;
      
      crewMap.add(character);
    }
  }
  
  if (sheet.getLastRow() > 1) {
    // Attempt to find frozen crew
    let crewNames = sheet.getRange(2, 1, sheet.getLastRow()).getValues().flat(); 
    let archetypeIds = sheet.getRange(2, sheet.getLastColumn(), sheet.getLastRow()).getValues().flat();
    
    for (i in parsedData.player.character.stored_immortals) {
      let immortal = parsedData.player.character.stored_immortals[i];
      let crewIndex = archetypeIds.indexOf(immortal.id);
      
      if (crewIndex >= 0) {
        let crewName = crewNames[crewIndex];
        crewMap.add({
          'name' : crewName,
          'frozen' : true,
          'archtype_id' : immortal.id, 
          'copies' : immortal.quantity
        });
      }
    }
  }
  
  let outputData = new Array();

  const headers = [
    'Name',	'Have', 'Short name', 
    'Max rarity', 'Rarity', 'Level', 'Frozen', 
    'Equipment', 'Tier', 'In portal', 'Collections',
    'Voyage Rank', 'Gauntlet Rank',
    'Command Core', 'Command Min', 'Command Max',
    'Diplomacy Core', 'Diplomacy Min', 'Diplomacy Max', 
    'Engineering Core', 'Engineering Min', 'Engineering Max',
    'Medicine Core', 'Medicine Min', 'Medicine Max',
    'Science Core', 'Science Min', 'Science Max',
    'Security Core', 'Security Min', 'Security Max',
    'Traits', 'Action name', 'Boosts Amount',
    'Initialize	Duration', 'Cooldown', 'Bonus Ability',
    'Trigger Uses per Battle (Not Used)', 'Handicap Type (Not Used)','Handicap Amount (Not Used)',
    'Accuracy', 'Crit Bonus', 'Crit Rating', 'Evasion', 'Charge Phases (Not Used)',
    'Character ID'];
  outputData.push(headers);
  
  let crewOwned = 0;
  let crewFrozen = 0;
  
  for (let row = 2; row < immortalData.length; ++row) {
    let crewName = immortalData[row][0];
    //console.info('Looking at ' + characterName);
    if (crewName == '')
      continue;
      
    let crew = crewMap.has(crewName) ? crewMap.get(crewName) : { 'name' : crewName, 'frozen' : false, 'copies' : 0 };
          
    while (crew) {
      let outputRow = [];
      let updaters = !crew.frozen && crew.copies ? playerUpdaters : immortalUpdaters;
      
      for (let column = 0; column < headers.length; ++column)  
        outputRow.push(updaters[column](crew, immortalData[row]));
      
      if (crew.frozen) 
        crewFrozen += crew.copies;
      else
        crewOwned += crew.copies;
      
      outputData.push(outputRow);
      crew = crew.duplicate;
    }
  }
  
  replaceContents_(sheet, outputData);
  app.getUi().alert(`You own ${crewOwned} crew and have ${crewFrozen} in the freezer.`);
}

/** Import Name, Rarity and quantity owned of every item into active sheet */
function importItemData(batch) {
  let targetSheet = getTargetSheet_('RawItemData', !batch);
  let items = importData_().player.character.items;
  let outputMap = new CrewMap();
  let output = [];
  
  output.push(['Name', 'Basic', 'Common', 'Uncommon', 'Rare', 'Super rare', 'Legendary']);
  
  for (i in items) {
    let item = items[i];
    if (!outputMap.has(item.name)) 
      outputMap.set(item.name, [item.name, 0, 0, 0, 0, 0, 0]);
    
    outputMap.get(item.name)[item.rarity + 1] = item.quantity;
  }
  
  let sortedKeys = Array.from(outputMap.keys()).sort();
  
  for (key in sortedKeys)
    output.push(outputMap.get(sortedKeys[key]));
    
  replaceContents_(targetSheet, output);
}

/** Import Voyage data into active sheet */
function importVoyageData(batch) {
  let targetSheet = getTargetSheet_("RawVoyageData", !batch);
  let output = [];
  let data = importData_().player.character;
  let voyageData = data.voyage_descriptions[0];
  
  let skillTypeMap = new Map();
  skillTypeMap.set(voyageData.skills.primary_skill, 'Primary');
  skillTypeMap.set(voyageData.skills.secondary_skill, 'Secondary');
  
  const parseTrait = trait => trait.replace('_', ' ')
                                   .replace('doctor', 'Physician')
                                   .replace(/\b(\w)/g, c => c.toUpperCase());
  
  let current = data.voyage[0];
  let voyager = current ? slot => current.crew_slots[slot].crew.name : slot => "None";
  
  output.push(["Voyage Status:", "", current ? current.state : "Not out", "", "", ""]);
  output.push(['', '', '', '', '', '']);
  output.push(['Skill', 'Type', 'Trait 1', 'Voyager 1', 'Trait 2', 'Voyager 2']);
  
  for (let i = 0; i < voyageData.crew_slots.length; i += 2) {
    let slot1 = voyageData.crew_slots[i];
    let slot2 = voyageData.crew_slots[i+1];
    let skill = slot1.skill;
    
    output.push([skill.charAt(0).toUpperCase() + skill.slice(1, -6), 
                 skillTypeMap.has(skill) ? skillTypeMap[skill] : 'Standard', 
                 parseTrait(slot1.trait), 
                 voyager(i),
                 parseTrait(slot2.trait),
                 voyager(i+1)]);
  }
  
  replaceContents_(targetSheet, output);
}
  }
  
  let headers = sheet.getRange(1, 1, 1, sheet.getLastColumn()).getDisplayValues()[0];
  let dataRange = sheet.getRange(2, 1, sheet.getLastRow(), sheet.getLastColumn());
  let sheetData = dataRange.getValues();
  let outputData = new Array();
  outputData.push(headers);
  
  let charactersUpdated = 0;
  let charactersFrozen = 0;
  
  for (let row = 0; row < sheetData.length; ++row) {
    let characterName = sheetData[row][0];
    //console.info("Looking at " + characterName);
   
    if (crewMap.has(characterName)) {
      console.info("Character " + characterName + " being updated");
      let character = crewMap.get(characterName);
      
      while (character) {
        let outputRow = new Array();
        for (let column = 0; column < headers.length; ++column) 
          outputRow.push(columnUpdaters[column](character, headers[column], sheetData[row][column]));
        
        outputData.push(outputRow);
        character = character.duplicate;
        ++charactersUpdated;
      }
      
      crewMap.delete(characterName);
    } else if (sheetData[row][1] && isImortalised(sheetData[row])) {
      // Frozen
      sheetData[row][6] = 1;
      outputData.push(sheetData[row]);
      ++charactersFrozen;
    } else {
      // TODO: Use 100 stat
    }
  }
  
  replaceContents_(sheet, outputData);
  SpreadsheetApp.getUi().alert(charactersUpdated.toString() + " characters updated and " + charactersRemoved.toString() + " characters removed.");
}

/** Import Name, Rarity and quantity owned of every item into active sheet */
function importItemData() {
  let items = importData_().player.character.items;
  let output = new Array();
  
  output.push(['Name', 'Rarity', 'Quantity owned']);
  
  for (i in items) {
    let item = items[i];
    output.push([item.name, item.rarity, item.quantity]);
    console.info(item.name + ": " + item.quantity.toString());
  }
  
  replaceContents_(SpreadsheetApp.getActiveSheet(), output);
}
function restoreBackup() {
  let ss = SpreadsheetApp.getActive();
  let targetName = ss.getActiveSheet().getName();
  let backupName = targetName + ' (backup)';
  
  if (ss.getSheetByName(backupName) != null) {
    ss.deleteActiveSheet();
    ss.setActiveSheet(ss.getSheetByName(backupName));
    ss.duplicateActiveSheet().setName(targetName).showSheet();
  } else {
    SpreadsheetApp.getUi().alert('There is no backup sheet');
  }
}

function createColumnUpdaters_() {
  const returnIfDefined = (value, defaultValue) => value ? value : defaultValue;
  const byName = (data, header, value) => returnIfDefined(data[header.toLowerCase().replace(/\s/g, "_")], value);
  const stat = function(data, header, value) {
    let name = header.split(" ")[0].toLowerCase() +  "_skill";
    let type = header.split(" ")[1];
    let skills = new Object(data.skills);
    
    if (!Object.keys(skills).includes(name)) 
      return value;
    
    if (type != "core")
      type = "range_" + type;
      
    return data.skills[name][type]
  };
  
  const noUpdate = (d, h, value) => value;
  const ship = (data, header, value) => byName(data["ship_battle"], header, 0);
  const custom = function(path) { return function(data, h, v) { 
    let indicies = path.split("/");
    let retVal = data;
    
    for (index in indicies) 
      retVal = retVal[indicies[index]];
    
    return retVal;
  }};
    
  return [
    noUpdate,
    (data, h, v) => true,
    noUpdate, noUpdate, byName, byName, noUpdate,
    (data, h, v) => { let values = []; for (equip in data.equipment) {values.push(data.equipment[equip][0]); }; return values.join(" "); },
    custom("equipment_rank"), noUpdate, noUpdate, noUpdate, noUpdate,
    stat, stat, stat,
    stat, stat, stat,
    stat, stat, stat,
    stat, stat, stat,
    stat, stat, stat,
    stat, stat, stat,
    noUpdate, noUpdate, noUpdate,
    custom("action/bonus_amount"), custom("action/initial_cooldown"), custom("action/duration"), custom("action/cooldown"),
    noUpdate, noUpdate, noUpdate, noUpdate, noUpdate,
    ship, ship, ship, ship, noUpdate
  ];
}

/** Imports crew data from an JSON file on */
function importCrewData() {
  let columnUpdaters = createColumnUpdaters_();
  let parsedData = importData_();
  let app = SpreadsheetApp;
  let sheet = app.getActiveSheet();
  let crewDict = new Map();

  for (i in parsedData.player.character.crew) {
    var character = parsedData.player.character.crew[i];
    crewDict.set(character.name, character);
  }
  
  
  let headers = sheet.getRange(1, 1, 1, sheet.getLastColumn()).getDisplayValues()[0];
  let dataRange = sheet.getRange(2, 1, sheet.getLastRow(), sheet.getLastColumn());
  let sheetData = dataRange.getValues();
  
  for (let row = 0; row < sheetData.length; ++row) {
    let characterName = sheetData[row][0];
    //console.info("Looking at " + sheetData[row]);
    
    if (crewDict.has(characterName)) {
      console.info("Character " + characterName + " being updated");
      let character = crewDict.get(characterName);
      
      for (let column = 0; column < headers.length; ++column) {
        sheetData[row][column] = columnUpdaters[column](character, headers[column], sheetData[row][column]);
      }
      
      crewDict.delete(characterName);
    }
  }
  
  dataRange.setValues(sheetData)
}
